# WEB前端动画简介

## 前序

谈及动画，我们首先提下前端网页的三大组成部分HTML，Javascript,CSS.这也是学习前端的三个基础，而这三个部分各有分工。

前端开发一个网页好比搭建一所房子。HTML是房子的基础架构，比如地基，墙壁，天窗，乃至房中一任家具，装饰物等都属于HTML的范畴；CSS是房子的风格样式，大到房子是中式还是欧式，现代风还是复古风，小到书桌是檀木的还是沉香木，圆的还是方的，都是由css来把控；而javascript负责的则是房子中所有可交互的东西，简单的如门窗的开合，细致如遥控器控制空调的开关，温湿的调节等。

了解了三者之间的分工及关联，再来谈动画就容易理解多了。作为前端开发，我们呈现给用户的不仅仅是一个可以供查看及使用的网页，更重要的是其样式风格投用户所好，交互体验让用户舒服。就像盖一所房子，如果这所房子仅仅是让用户能住在里面，挡下风，遮个雨，其实搭个帐篷就足够了。现实是用户不可能接受这样的交付。那么怎么让用户有好的体验呢？比如房间内的窗户，有遮阳的窗帘，窗帘有不同的风格（css决定），用户要拉开窗帘，就可以提供很多方式，窗帘从下往上，从中间到两边，从左至右等，而这种种方式都取决于用户手轻轻的一拉，便捷且优雅。这映射到我们构建网页上，也就是动画需求的由来了。

## 动画原理
![手翻书](/img/handbook.gif)  
小时候大家印象中可能都会见过类似这样的手翻书，每页的图画相互衔接，快速翻动时，看起来就像人物动起来一样，这或许是大多数人初识动画的场景。

在理解动画原理之前，我们先了解几个相关概念：

### 屏幕刷新频率
当前市面上常见的显示器有两种，即CRT（传统显示器）和LCD（液晶显示器）。

屏幕刷新频率主要是就CRT来说的。屏幕上的图形图像是由一个个因电子束击打而发光的荧光点组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光。这里屏幕刷新频率指的就是电子束每秒打击荧光粉的次数。  

对于LCD来说则不存在刷新率的问题，它根本就不需要刷新。因为LCD中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以LCD不会有“不断充放电”而引起的闪烁现象。

```
拓展：对于传统显示器来讲，刷新频率越低，图像闪烁和抖动的就越厉害，眼睛疲劳得就越快。有时会引起眼睛酸痛，头晕目眩等症状。因为60Hz正好与日光灯的刷新频率相近，所以当显示器处于60Hz的刷新频率时会产生令人难受的频闪效应。而当采用70Hz以上的刷新频率时可基本消除闪烁。因此，70Hz的刷新频率是在显示器稳定工作时的最低要求。（一般设置在70-85之间，过低影像人的视力，过高则会加速显示器的老化）

而对于液晶显示器，设置为默认的60HZ即可
```

通过以上我们知道：即使我们在电脑面前什么也不做，屏幕上显示的只是静态网页，显示器也会一直以一定的频率不断更新屏幕上的图像，那么就会产生另一个疑问：为什么我们感觉不到这个变化呢？这就涉及到下面一个概念——视觉滞留效应

### 视觉滞留效应

所谓视觉滞留效应，即当人眼所看到的影像消失后，影像仍会在大脑中停留一段时间的现象。停留时间大约是1/24s（约32ms）。

比如：直视太阳数秒后，人眼将残留一个强光源的影像。我们日常使用的日光灯每秒大约熄灭100余次，但我们基本感觉不到日光灯的闪动。这都是因为视觉暂留的作用。所以，要达成最基本的视觉暂留效果至少需要10fps（参考视频的画面更新率）。

而针对显示器的屏幕刷新频率——以60HZ为例，刷新前后的2张图像的间隔则是16.7ms(1000/60),是小于视觉停留时间的。这就导致前面的图像在大脑中的印象还没消失，后面的图像就又进来了，这样就让我们误以为图像是静止不动的。假设屏幕的刷新频率是1s/次（这个值远远大于视觉停留时间），屏幕上的图像就会出现严重的闪烁，一下出现一下消失，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。

聊完以上2个概念，再回到动画的原理上，就比较容易理解了。

### 计算机动画原理

通过上面的讲述我们知道，我们在显示器上所看到的图像是在以60HZ的频率进行刷新，因为刷新频率很高，我们感觉不到它一直在刷新。   

而动画的实质就是让人眼看到图像因为刷新而产生连续变化的视觉效果，且这个变化要以连贯的，平滑的方式过渡。那么怎么实现这种效果呢？

现在我们知道刷新频率为60Hz的屏幕每16.7ms会刷新一次，那么我们在屏幕每次刷新前，将图像的位置向左移动一个微小的距离，比如1px。这样以来，屏幕每次刷出来的图像位置都比前一个要差1px，这时候你就会看到图像在移动：由于我们人眼的视觉滞留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。

清楚了动画实现的原理，那么web前端实现动画的方式又有那些呢？

## WEB前端动画实现的方式简述

### 1.纯JS实现  
该实现方式的主要思想就是借助javascript中的定时函数setTimeout和setInterval进行函数回调，来持续更新某个dom节点的某个css属性，以此来达到元素样式变化的效果。  
常见的的前端 滚动字幕 效果就可以通过该方式实现。
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        #subtitle{
            width: 300px;
            height: 144px;
            position: relative;
            border:1px dotted #C6C6C6;
            overflow: hidden;
        }
        #subtitle ul{
            position: absolute;
            width: 100%;
            top: 0;
            margin: 0;
            padding: 0;
        }
        #subtitle ul li{
            list-style: none;
            height: 36px;
            line-height: 36px;
        }
    </style>
</head>
<body>
<div id="subtitle">
    <ul id="subContent">
        <li>天地玄黄宇宙洪荒唐宋元明清</li>
        <li>赵钱孙李周吴郑王东西南北中</li>
        <li>天地玄黄宇宙洪荒唐宋元明清</li>
        <li>赵钱孙李周吴郑王东西南北中</li>
        <li>天地玄黄宇宙洪荒唐宋元明清</li>
        <li>赵钱孙李周吴郑王东西南北中</li>
    </ul>
</div>
<script type="text/javascript">
    var ul = document.getElementById("subContent");
    ul.innerHTML += ul.innerHTML;
    ul.style.top = 0;
    ul.style.height = ul.clientHeight + "px";
    var speed = 1;
    function  run() {
        if(ul.offsetTop < -ul.offsetHeight/2){
            ul.style.top = 0;
        }
        ul.style.top = ul.offsetTop - speed + "px";
    }
    var timer = setInterval(run,16);
    ul.onmouseover = function () {
        if(timer){
            clearInterval(timer);
        }
    };
    ul.onmouseout = function () {
        timer = setInterval(run,16);
    };
</script>
</body>
</html>
```
详见demos/scrollBar.html示例文件

那么settimeout和setInterval是如何具体实现动画效果的呢？我们以制作一个进度条的动画为例，代码如下

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>动画示例</title>
    <style>
        #progressBarContainer{
            border: 1px dotted gray;
            width: 100%;
            height: 300px;
        }
        #progressBarContainer .bar{
            width: 0;
            height: 30px;
            line-height: 30px;
            color: white;
            background-color: #1b6d85;
            box-sizing: border-box;
            text-align: center;
            margin: 10px 0 10px 20px;
        }
    </style>
</head>
<body>
<h1>JS原生动画</h1>
<button id="startBtn">启动</button>
<div id="progressBarContainer">
    <div class="bar" style="width: 0"></div>
    <div class="bar" style="width: 0"></div>
    <div class="bar" style="width: 0"></div>
</div>
<script>
    var step = 5,totalLength = 500;
    var interval = 16;
    var startBtn = document.getElementById("startBtn");
    var bar1 = document.getElementsByClassName("bar")[0];
    var bar2 = document.getElementsByClassName("bar")[1];
    var bar3 = document.getElementsByClassName("bar")[2];

    startBtn.addEventListener('click',function () {
        loadBar1();
        loadBar2();
        loadBar3();
    });
    //采用setTimeout
    function loadBar1() {
        if(parseInt(bar1.style.width) < totalLength){
            bar1.style.width = parseInt(bar1.style.width) + step + "px";
            bar1.innerHTML = parseInt(bar1.style.width)/step + "%";
            var timer1 = setTimeout(function () {
                loadBar1();
            },interval)
        }else{
            clearTimeout(timer1);
        }
    }
    //采用setInterval
    function loadBar2() {
        var timer2 = setInterval(function () {
            if(parseInt(bar2.style.width) < totalLength){
                bar2.style.width = parseInt(bar2.style.width) + step + "px";
                bar2.innerHTML = parseInt(bar2.style.width)/step + "%";
            }else{
                clearInterval(timer2);
            }
        },interval)
    }
    //采用requestAnimationFrame
    function loadBar3() {
        if(parseInt(bar3.style.width) < totalLength){
            bar3.style.width = parseInt(bar3.style.width) + step + "px";
            bar3.innerHTML = parseInt(bar3.style.width)/step + "%";
            var timer3 = requestAnimationFrame(loadBar3)
        }else{
            cancelAnimationFrame(timer3);
        }
    }
//    requestAnimationFrame方法不需要手动设置间隔时间，而是由浏览器控制自动设置最佳间隔时间。该方法是H5提供的一种专门解决动画更新的API
//    浏览器会自动以最合适的频率去刷新动画
</script>
</body>
</html>
```
上面示例中分别采用了setTimeout,setInterval和requestAnimationFrame三种方法来绘制进度条动画，前两种大家用的相对较多，第三种大家可能会在canvas动画中碰到过，这里先放后面，暂且先谈一下前两者存在的问题。

![浏览器队列阻塞](/img/Animation.gif)

运行代码我们可以发现，假设我们将两者的间隔时间都设置为16ms，近似于可以展示最平滑动画效果的时间，他们执行的快慢都是有区别的，而且和第三种相比会存在轻微抖动，卡顿的情况。而且setInterval在执行期间速度甚至还有后来居上的情况，并没有想象中那么平滑稳定，这是为什么呢？

首先我们明白：setTimeout动画的实质就是通过设置一个指定的时间间隔来不断改变图像的位置或内容来呈现出动画的效果，那么这个执行时间是确定的吗？换句话说是我们指定的时间间隔吗？答案显然不是的。

1.我们指定的时间间隔（或者说延迟时间）并不是函数何时再次执行的时间，而是将代码添加到浏览器的UI线程队列中的时间。这样就会造成两种情况：

（1）假如回调函数耗时较多，比你设定的时间要长，那么一旦延迟时间到了，它将会排队执行下一次函数，（或者说将下一个任务放进UI线程队列中，但放到下一个线程队列中却不一定就要执行，因为js的线程是异步的，只有当上一个任务执行完，才会执行下一个任务）即使上一个函数还未执行完。这样一直重复下去，很快队列中就会排上大量的计时器代码，从而导致浏览器阻塞，不堪重负。如下图所示：

（2）假如回调函数的执行时间没有设定的时间长，为了动画效果尽量的平滑，谨慎起见，我们一般会选择比屏幕刷新频率略高的频率。但这样却会导致不必要的绘制，也就是说当持续几次后，当屏幕再次刷新时，有些帧已经绘制过了（当时屏幕处于未刷新状态），这样屏幕将会刷新最近一个帧，这样就导致一些帧无效，造成丢帧现象。如下图所示：

![浏览器队列阻塞](/img/figure1.png)

2.屏幕刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕刷新时间同步。我们不可能用代码控制每个浏览器的计时器时间间隔，这显然是不现实的。

![丢帧现象](/img/figure2.png)

另外，setTimeout和setInterval还存在一个问题，即当浏览器窗口最小化时，JavaScript计时器在背景标签下仍旧持续运行。而浏览器继续运行看不见的动画，势必会导致不必要的 CPU 和电池寿命的消耗。在移动设备尤其严重。

鉴于以上这些问题的存在，后续就出现了新的解决方案，也就是代码示例中的第三种————requestAnimationFrame。且由代码动画示例中我们可以看到三的进度条动画相对很平滑，抖动和卡顿都不明显（也不能一定说就不存在），那么requestAnimatinFrame是如何解决JavaScript计时器动画无法完美呈现动画的问题呢？

#### 后来者requestAnimationFrame


### 2.CSS动画  
这里的css动画主要指的是CSS3中Animation属性和keyframes规则，严格意义上来说transition并不是，为什么呢？

因为transition只能实现某个标签元素样式或状态改变时进行平滑的动画效果过渡，并不能马上改变。也就是说它能实现动画这个过程，但是需要一个触发条件，比如：hover伪类，通过鼠标移动到添加了transition的元素上来触发动画的执行。

优缺点分析：  
优点：（1）代码相对简单
（2）CSS3的动画是利用C语言编写的，他是系统层面的动画，动画的实现交由浏览器来完成，优化了内存的消耗和dom的操作。
（3）强制硬件加速，利用GPU提升动画效果
