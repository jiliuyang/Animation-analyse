# WEB前端动画简介

## 前序

谈及动画，我们首先提下前端网页的三大组成部分HTML，Javascript,CSS.这也是学习前端的三个基础，而这三个部分各有分工。

前端开发一个网页好比搭建一所房子。HTML是房子的基础架构，比如地基，墙壁，天窗，乃至房中一任家具，装饰物等都属于HTML的范畴；CSS是房子的风格样式，大到房子是中式还是欧式，现代风还是复古风，小到书桌是檀木的还是沉香木，圆的还是方的，都是由css来把控；而javascript负责的则是房子中所有可交互的东西，简单的如门窗的开合，细致如遥控器控制空调的开关，温湿的调节等。

了解了三者之间的分工及关联，再来谈动画就容易理解多了。作为前端开发，我们呈现给用户的不仅仅是一个可以供查看及使用的网页，更重要的是其样式风格投用户所好，交互体验让用户舒服。就像盖一所房子，如果这所房子仅仅是让用户能住在里面，挡下风，遮个雨，其实搭个帐篷就足够了。现实是用户不可能接受这样的交付。那么怎么让用户有好的体验呢？比如房间内的窗户，有遮阳的窗帘，窗帘有不同的风格（css决定），用户要拉开窗帘，就可以提供很多方式，窗帘从下往上，从中间到两边，从左至右等，而这种种方式都取决于用户手轻轻的一拉，便捷且优雅。这映射到我们构建网页上，也就是动画需求的由来了。

## 动画原理
![手翻书](/img/handbook.gif)  
小时候大家印象中可能都会见过类似这样的手翻书，每页的图画相互衔接，快速翻动时，看起来就像人物动起来一样，这或许是大多数人初识动画的场景。

在理解动画原理之前，我们先了解几个相关概念：

### 屏幕刷新频率
当前市面上常见的显示器有两种，即CRT（传统显示器）和LCD（液晶显示器）。

屏幕刷新频率主要是就CRT来说的。屏幕上的图形图像是由一个个因电子束击打而发光的荧光点组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光。这里屏幕刷新频率指的就是电子束每秒打击荧光粉的次数。  

对于LCD来说则不存在刷新率的问题，它根本就不需要刷新。因为LCD中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以LCD不会有“不断充放电”而引起的闪烁现象。

```
拓展：对于传统显示器来讲，刷新频率越低，图像闪烁和抖动的就越厉害，眼睛疲劳得就越快。有时会引起眼睛酸痛，头晕目眩等症状。因为60Hz正好与日光灯的刷新频率相近，所以当显示器处于60Hz的刷新频率时会产生令人难受的频闪效应。而当采用70Hz以上的刷新频率时可基本消除闪烁。因此，70Hz的刷新频率是在显示器稳定工作时的最低要求。（一般设置在70-85之间，过低影像人的视力，过高则会加速显示器的老化）

而对于液晶显示器，设置为默认的60HZ即可
```

通过以上我们知道：即使我们在电脑面前什么也不做，屏幕上显示的只是静态网页，显示器也会一直以一定的频率不断更新屏幕上的图像，那么就会产生另一个疑问：为什么我们感觉不到这个变化呢？这就涉及到下面一个概念——视觉滞留效应

### 视觉滞留效应

所谓视觉滞留效应，即当人眼所看到的影像消失后，影像仍会在大脑中停留一段时间的现象。停留时间大约是1/24s（约32ms）。

比如：直视太阳数秒后，人眼将残留一个强光源的影像。我们日常使用的日光灯每秒大约熄灭100余次，但我们基本感觉不到日光灯的闪动。这都是因为视觉暂留的作用。所以，要达成最基本的视觉暂留效果至少需要10fps（参考视频的画面更新率）。

而针对显示器的屏幕刷新频率——以60HZ为例，刷新前后的2张图像的间隔则是16.7ms(1000/60),是小于视觉停留时间的。这就导致前面的图像在大脑中的印象还没消失，后面的图像就又进来了，这样就让我们误以为图像是静止不动的。假设屏幕的刷新频率是1s/次（这个值远远大于视觉停留时间），屏幕上的图像就会出现严重的闪烁，一下出现一下消失，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。

聊完以上2个概念，再回到动画的原理上，就比较容易理解了。

### 计算机动画原理

通过上面的讲述我们知道，我们在显示器上所看到的图像是在以60HZ的频率进行刷新，因为刷新频率很高，我们感觉不到它一直在刷新。   

而动画的实质就是让人眼看到图像因为刷新而产生连续变化的视觉效果，且这个变化要以连贯的，平滑的方式过渡。那么怎么实现这种效果呢？

现在我们知道刷新频率为60Hz的屏幕每16.7ms会刷新一次，那么我们在屏幕每次刷新前，将图像的位置向左移动一个微小的距离，比如1px。这样以来，屏幕每次刷出来的图像位置都比前一个要差1px，这时候你就会看到图像在移动：由于我们人眼的视觉滞留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。

清楚了动画实现的原理，那么web前端实现动画的方式又有那些呢？

## WEB前端动画实现的方式简述

### 1.纯JS实现  
该实现方式的主要思想就是借助javascript中的定时函数setTimeout和setInterval进行函数回调，来持续更新某个dom节点的某个css属性，以此来达到元素样式变化的效果。  
常见的的前端 滚动字幕 效果就可以通过该方式实现。
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        #subtitle{
            width: 300px;
            height: 144px;
            position: relative;
            border:1px dotted #C6C6C6;
            overflow: hidden;
        }
        #subtitle ul{
            position: absolute;
            width: 100%;
            top: 0;
            margin: 0;
            padding: 0;
        }
        #subtitle ul li{
            list-style: none;
            height: 36px;
            line-height: 36px;
        }
    </style>
</head>
<body>
<div id="subtitle">
    <ul id="subContent">
        <li>天地玄黄宇宙洪荒唐宋元明清</li>
        <li>赵钱孙李周吴郑王东西南北中</li>
        <li>天地玄黄宇宙洪荒唐宋元明清</li>
        <li>赵钱孙李周吴郑王东西南北中</li>
        <li>天地玄黄宇宙洪荒唐宋元明清</li>
        <li>赵钱孙李周吴郑王东西南北中</li>
    </ul>
</div>
<script type="text/javascript">
    var ul = document.getElementById("subContent");
    ul.innerHTML += ul.innerHTML;
    ul.style.top = 0;
    ul.style.height = ul.clientHeight + "px";
    var speed = 1;
    function  run() {
        if(ul.offsetTop < -ul.offsetHeight/2){
            ul.style.top = 0;
        }
        ul.style.top = ul.offsetTop - speed + "px";
    }
    var timer = setInterval(run,16);
    ul.onmouseover = function () {
        if(timer){
            clearInterval(timer);
        }
    };
    ul.onmouseout = function () {
        timer = setInterval(run,16);
    };
</script>
</body>
</html>
```
详见demos/scrollBar.html示例文件

那么settimeout和setInterval是如何具体实现动画效果的呢？我们以制作一个进度条的动画为例，代码如下

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>动画示例</title>
    <style>
        #progressBarContainer{
            border: 1px dotted gray;
            width: 100%;
            height: 300px;
        }
        #progressBarContainer .bar{
            width: 0;
            height: 30px;
            line-height: 30px;
            color: white;
            background-color: #1b6d85;
            box-sizing: border-box;
            text-align: center;
            margin: 10px 0 10px 20px;
        }
    </style>
</head>
<body>
<h1>JS原生动画</h1>
<button id="startBtn">启动</button>
<div id="progressBarContainer">
    <div class="bar" style="width: 0"></div>
    <div class="bar" style="width: 0"></div>
    <div class="bar" style="width: 0"></div>
</div>
<script>
    var step = 5,totalLength = 500;
    var interval = 16;
    var startBtn = document.getElementById("startBtn");
    var bar1 = document.getElementsByClassName("bar")[0];
    var bar2 = document.getElementsByClassName("bar")[1];
    var bar3 = document.getElementsByClassName("bar")[2];

    startBtn.addEventListener('click',function () {
        loadBar1();
        loadBar2();
        loadBar3();
    });
    //采用setTimeout
    function loadBar1() {
        if(parseInt(bar1.style.width) < totalLength){
            bar1.style.width = parseInt(bar1.style.width) + step + "px";
            bar1.innerHTML = parseInt(bar1.style.width)/step + "%";
            var timer1 = setTimeout(function () {
                loadBar1();
            },interval)
        }else{
            clearTimeout(timer1);
        }
    }
    //采用setInterval
    function loadBar2() {
        var timer2 = setInterval(function () {
            if(parseInt(bar2.style.width) < totalLength){
                bar2.style.width = parseInt(bar2.style.width) + step + "px";
                bar2.innerHTML = parseInt(bar2.style.width)/step + "%";
            }else{
                clearInterval(timer2);
            }
        },interval)
    }
    //采用requestAnimationFrame
    function loadBar3() {
        if(parseInt(bar3.style.width) < totalLength){
            bar3.style.width = parseInt(bar3.style.width) + step + "px";
            bar3.innerHTML = parseInt(bar3.style.width)/step + "%";
            var timer3 = requestAnimationFrame(loadBar3)
        }else{
            cancelAnimationFrame(timer3);
        }
    }
//    requestAnimationFrame方法不需要手动设置间隔时间，而是由浏览器控制自动设置最佳间隔时间。该方法是H5提供的一种专门解决动画更新的API
//    浏览器会自动以最合适的频率去刷新动画
</script>
</body>
</html>
```
具体代码见"demos/progressAnimation.html"

上面示例中分别采用了setTimeout,setInterval和requestAnimationFrame三种方法来绘制进度条动画，前两种大家用的相对较多，第三种大家可能会在canvas动画中碰到过，这里先放后面，暂且先谈一下前两者存在的问题。

![浏览器队列阻塞](/img/Animation.gif)

运行代码我们可以发现，假设我们将两者的间隔时间都设置为16ms，近似于可以展示最平滑动画效果的时间，他们执行的快慢都是有区别的，而且和第三种相比会存在轻微抖动，卡顿的情况。而且setInterval在执行期间速度甚至还有后来居上的情况，并没有想象中那么平滑稳定，这是为什么呢？

首先我们明白：setTimeout动画的实质就是通过设置一个指定的时间间隔来不断改变图像的位置或内容来呈现出动画的效果，那么这个执行时间是确定的吗？换句话说是我们指定的时间间隔吗？答案显然不是的。

1.我们指定的时间间隔（或者说延迟时间）并不是函数何时再次执行的时间，而是将代码添加到浏览器的UI线程队列中的时间。这样就会造成两种情况：

（1）假如回调函数耗时较多，比你设定的时间要长，那么一旦延迟时间到了，它将会排队执行下一个函数，（或者说将下一个任务放进UI线程队列中，但放到下一个线程队列中却不一定就要执行，因为js的线程是异步的，只有当上一个任务执行完，才会执行下一个任务）即使上一个函数还未执行完。这样一直重复下去，很快队列中就会排上大量的计时器代码，从而导致浏览器阻塞，不堪重负。如下图所示：

![浏览器队列阻塞](/img/figure1.png)

（2）假如回调函数的执行时间没有设定的时间长，为了动画效果尽量的平滑，谨慎起见，我们一般会选择比屏幕刷新频率略高的频率。但这样却会导致不必要的绘制，也就是说当持续几次后，当屏幕再次刷新时，有些帧已经绘制过了（当时屏幕处于未刷新状态），这样屏幕将会刷新最近一个帧，这样就导致一些帧无效，造成丢帧现象。如下图所示：

![丢帧现象](/img/figure2.png)

2.屏幕刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕刷新时间同步。我们不可能用代码控制每个浏览器的计时器时间间隔，这显然是不现实的。

另外，setTimeout和setInterval还存在一个问题，即当浏览器窗口最小化或者动画处于隐藏区域时，JavaScript计时器在背景标签下仍旧持续运行。而浏览器继续运行看不见的动画，势必会导致不必要的 CPU 和电池寿命的消耗。在移动设备尤其严重。

鉴于以上这些问题的存在，后续就出现了新的解决方案，也就是代码示例中的第三种————requestAnimationFrame。且由代码动画示例中我们可以看到三的进度条动画相对很平滑，抖动和卡顿都不明显（也不能一定说就不存在），那么requestAnimatinFrame是如何解决JavaScript计时器动画无法完美呈现动画的问题呢？

#### requestAnimationFrame简述

requestAnimationFrame之所以能解决计时器动画的缺陷，就在于它把绘制动画的任务直接交给了浏览器，换句话说就是由浏览器来确定回调函数的执行时机。

简单的说，如果屏幕刷新频率是60HZ，那么函数就每隔16.7ms执行一次，如果是75HZ，函数执行的时间间隔就会变成1000/75=13.3ms。requestAnimationFrame的步调保持与系统的屏幕刷新步调一致，这样就确保了在每一次的屏幕刷新时间间隔中回调函数只会被执行一次。这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

#### requestAnimationFrame 做了什么
浏览器了解标签和窗口的状态，页面哪部分可见或不可见，了解当浏览器准备绘制时，其它的动画也在运行。requestAnimationFrame 让浏览器负责，允许它使用这些信息优化动画的调度，解决了我们先前讨论的 JavaScript 计时器问题。requestAnimationFrame 的流程像这样：

首先，它仅仅绘制用户可见的动画。这意味着没把 CPU 或电池寿命浪费在绘制处于背景标签，最小化窗口，或者页面隐藏区域的动画上。  
第二，当浏览器准备好绘制时（空闲时），才绘制一帧，此时没有等待中的帧。意味着用 requestAnimationFrame 绘制动画不可能出现多个排队的回调函数，或者阻塞浏览器。  
第三，由于浏览器准备好时（空闲时）才绘制帧，不会有等待绘制的帧，没有多余的帧绘制。因此动画更平滑，CPU 和电池使用被进一步优化。
我只是说直到当前的帧绘制完成，都没有额外的回调函数在排队。如果你多次调用 requestAnimationFrame() ，每次调用都有回调函数在排队。

另外，浏览器可以把同一页面的多处动画，保持在单一的回流和重绘周期里。

#### requestAnimationFrame 没做什么

1.创建一个连续的动画；它仅安排单独的更新，通过一个返回的 id 号识别。如果还有后续的动画帧，requestAnimationFrame 将在回调函数里再次被调用。如果需要停止动画，使用 cancelAnimationFrame(id) 。

2.确保真正需要时再绘制。

3.保证动画的同步性。如果你同时开始两个动画，但是一个在可见区域，另一个不是，第一个动画将执行，另一个则不会；当第二个变得可见时，它们也许不同步了。如果你关心这个，在写动画代码的时候要注意， 指定一个参数确保所有需要同步的动画状态，不受可见程度的影响（如一组动画从开始以来经过的时间），而不是根据每个动画的前一帧。

4.即使你尝试用任何方法，触发回调中间的回流（像 getComputedStyle() ，正常情况下，可以触发回流和重绘），它也会等到回调函数执行完毕才绘制。

#### requestAnimationFrame的优势

1.CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 会继续在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处于未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。

2.函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。

综合以上我们清楚了requestAnimationFrame的基本原理及其优势，那么怎么运用呢？以前面的滚动字幕代码为例，我们对其进行改造如下：

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>requestAnimationFrame滚动屏幕</title>
    <style>
        #subtitle{
            width: 300px;
            height: 144px;
            position: relative;
            border:1px dotted #C6C6C6;
            overflow: hidden;
        }
        #subtitle ul{
            position: absolute;
            width: 100%;
            top: 0;
            margin: 0;
            padding: 0;
        }
        #subtitle ul li{
            list-style: none;
            height: 36px;
            line-height: 36px;
        }
    </style>
</head>
<body>
<div id="subtitle">
    <ul id="subContent">
        <li>天地玄黄宇宙洪荒唐宋元明清</li>
        <li>赵钱孙李周吴郑王东西南北中</li>
        <li>天地玄黄宇宙洪荒唐宋元明清</li>
        <li>赵钱孙李周吴郑王东西南北中</li>
        <li>天地玄黄宇宙洪荒唐宋元明清</li>
        <li>赵钱孙李周吴郑王东西南北中</li>
    </ul>
</div>
<script type="text/javascript">
    var ul = document.getElementById("subContent");
    ul.innerHTML += ul.innerHTML;
    ul.style.top = 0;
    ul.style.height = ul.clientHeight + "px";
    var speed = 1;
    var timer;
    function run() {
        if(ul.offsetTop < -ul.offsetHeight/2){
            ul.style.top = 0;
        }
        ul.style.top = ul.offsetTop - speed + "px";
        timer = requestAnimationFrame(run);
      //var timer = requestAnimationFrame(run);
    }
    timer = requestAnimationFrame(run);
    //
    ul.onmouseover = function () {
        if(timer){
            cancelAnimationFrame(timer);
        }
    };
    ul.onmouseout = function () {
        timer = requestAnimationFrame(run);
    };
</script>
</body>
</html>
```
具体代码见"demos/scrollBar2.html"

其中requestAnimationFrame是启动动画的api方法，cancelAnimationFrame是取消动画的API。与setInterval计时器的使用方法类似，但有一点我们看到，在requestAnimationFrame的回调函数中再次执行了该API接口，不像setInterval一样仅在外面调用了一次。如果run函数中不在再次引用的话，requestAnimationFrame也就只会执行一次。也就是说requestAnimationFrame可以说是setTimeout的升级版处理方案，它处理的外在机制和setTimeout相似，但是处理的更加精准，细腻。

了解了requestAnimationFrame的使用方法，那么就剩下最后一个问题：兼容性问题。因为不同的浏览器需要有不同的前缀，且有些过低版本的浏览器还不支持，这时候就要采用优雅降级的方法对其进行封装，使其优先使用过高级特性，在不支持的情况下最后使用setTimeout定时器。

以下是github上提供的polyfill方法代码：

```
if (!Date.now)

    Date.now = function() { return new Date().getTime(); };


(function() {

    'use strict';

    

    var vendors = ['webkit', 'moz'];

    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {

        var vp = vendors[i];

        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];

        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame']

                                   || window[vp+'CancelRequestAnimationFrame']);

    }

    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy

        || !window.requestAnimationFrame || !window.cancelAnimationFrame) {

        var lastTime = 0;

        window.requestAnimationFrame = function(callback) {

            var now = Date.now();

            var nextTime = Math.max(lastTime + 16, now);

            return setTimeout(function() { callback(lastTime = nextTime); },

                              nextTime - now);

        };

        window.cancelAnimationFrame = clearTimeout;

    }

}());
```


### 2. CSS 动画  
上面我们知道CSS是构成页面三要素的样式掌控者，而javascript才是实现动画交互的执行者。但随着技术的发展，尤其是CSS3的出现改变了只有javascript才能实现动画的专属特权。CSS3除了增加革命性的创新功能外，还提供了对动画的支持，可以用来实现旋转、缩放、平移、扭曲和过渡效果等等，这些功能再一次证明了CSS3功能的强大和无限潜能。

因为transition只能实现某个标签元素样式或状态改变时进行平滑的动画效果过渡，并不能马上改变。也就是说它能实现动画这个过程，但是需要一个触发条件，比如：hover伪类，通过鼠标移动到添加了transition的元素上来触发动画的执行。

#### Transform

要谈CSS3 动画，首先要弄明白CSS3新增的一个属性：transform。该属性可实现元素的旋转，缩放，平移，扭曲及矩阵变形等效果，是CSS3元素变形的基础。

```
语法
   transform ： none | <transform-function> [ <transform-function> ]* 
   也就是：
   transform: rotate | scale | skew | translate |matrix;
```

其中none表示不进行变换，后者表示一个或多个变换函数，换句话说就是可以同时对一个元素的多个transform属性进行操作，注意：中间需用空格隔开。

接下来在讲transform的各种属性之前，先剖析一个概念，即transform不是动画属性，而是静态属性。意思是说transform只能实现元素的变形结果，而不能呈现元素的变形过程。这在我们进行demo测试时就可以得到验证。

##### 具体用法介绍

一。旋转rotate  
rotate(<angle>) ：通过指定的角度参数对原元素指定一个2D rotation（2D 旋转），需先有transform-origin属性的定义。transform-origin定义的是旋转的基点，其中angle是指旋转角度，如果设置的值为正数表示顺时针旋转，如果设置的值为负数，则表示逆时针旋转。如：transform:rotate(30deg):

![旋转](/img/rotate.png)

二。缩放scale  

缩放分为三种情况：  
scale(sx,sy): 元速水平方向和垂直方向同时缩放  
scaleX(sx): 元素水平方向进行缩放  
scaleY(sy): 元素垂直方向进行缩放
```
这三种情况拥有相同的缩放中心点和基数，其中心点就是元素的中心位置，缩放基数为1，如果其值大于1元素就放大，反之其值小于1，元素缩小。如果是0，则元素将不可见。
```
1.scale(<number>[, <number>])：提供执行[sx,sy]缩放矢量的两个参数指定一个2D scale（2D缩放）。如果第二个参数未提供，则取与第一个参数一样的值。scale(X,Y)是用于对元素进行缩放，可以通过transform-origin对元素的基点进行设置，同样基点在元素中心位置；基中X表示水平方向缩放的倍数，Y表示垂直方向的缩放倍数，而Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。并以X为准。如：transform:scale(2,1.5):

![同时缩放](/img/scale-x-y.png)

2、scaleX(<number>) ： 相当于scale(x,1)。scaleX表示元素只在X轴(水平方向)缩放元素，他的默认值是(1,1)，其基点一样是在元素的中心位置，我们同样是通过transform-origin来改变元素的基点。如：transform:scaleX(2):

![水平缩放](/img/scale-x.png)

3、scaleY(<number>) ： 相当于scalc(1,y)。scaleY表示元素只在Y轴（垂直方向）缩放元素，其基点同样是在元素中心位置，可以通过transform-origin来改变元素的基点。如transform:scaleY(2):

![垂直缩放](/img/scale-y.png)

三。平移translate

同缩放一样，平移也分为三种情况:
```
translate(sx,sy): 元素水平方向和垂直方向同时平移  
translateX(sx): 元素水平方向进行平移  
translateY(sy): 元素垂直方向进行平移
```
1、translate(<translation-value>[, <translation-value>]) ：通过矢量[tx, ty]指定一个2D translation，tx 是第一个过渡值参数，ty 是第二个过渡值参数选项。如果 未被提供，则ty以 0 作为其值。也就是translate(x,y),它表示对象进行平移，按照设定的x,y参数值,当值为负数时，反方向移动物体，其基点默认为元素 中心点，也可以根据transform-origin进行改变基点。如transform:translate(100px,20px):

![同时平移](/img/translate-x-y.png)
2、translateX(<translation-value>) ： 通过给定一个X方向上的数目指定一个translation。只向x轴进行移动元素，同样其基点是元素中心点，也可以根据transform-origin改变基点位置。如：transform:translateX(100px):

![水平平移](/img/translate-x.png)
3、translateY(<translation-value>) ：通过给定Y方向的数目指定一个translation。只向Y轴进行移动，基点在元素心点，可以通过transform-origin改变基点位置。如：transform:translateY(20px):

![垂直平移](/img/translate-y.png)

四。变形skew

同缩放，平移类似，扭曲也分三种情况：

1、skew(<angle>,<angle>) ：X轴Y轴上的skew transformation（斜切变换）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。skew是用来对元素进行扭曲变行，第一个参数是水平方向扭曲角度，第二个参数是垂直方向扭曲角度。其中第二个参数是可选参数，如果没有设置第二个参数，那么Y轴为0deg。同样是以元素中心为基点，我们也可以通过transform-origin来改变元素的基点位置。如：transform:skew(30deg,10deg):

![同时扭曲](/img/skew-x-y.png)
2、skewX(<angle>) ： 按给定的角度沿X轴指定一个skew transformation（斜切变换）。skewX是使元素以其中心为基点，并在水平方向（X轴）进行扭曲变行，同样可以通过transform-origin来改变元素的基点。如：transform:skewX(30deg)

![水平扭曲](/img/skew-x.png)
3、skewY(<angle>) ： 按给定的角度沿Y轴指定一个skew transformation（斜切变换）。skewY是用来设置元素以其中心为基点并按给定的角度在垂直方向（Y轴）扭曲变形。同样我们可以通过transform-origin来改变元素的基点。如：transform:skewY（10deg）

![垂直扭曲](/img/skew-y.png)

五、矩阵Matrix
Matrix是以一个含六值的(a,b,c,d,e,f)变换矩阵的形式指定一个2D变换，这个用法相对来说比较高级，一般用的并不多，这里就不多提，有兴趣可以自行研究。

### transform-origin

在介绍上述几种transform属性的过程中，我们频繁提到了一个transform-origin属性，字面上我们可以看出该属性指的是变形原点（或者说基点）。它的默认值为center center,也可以写作50% 50%。也就是在一个元素的中心位置。

默认情况下,transform的各类变形都是由默认基点——即中心点进行的，但是有时候我们在实现一些特殊效果的需求下，会希望transform的变形基点的位置移动一下，这个时候就需要用到transform-origin来改变变形基点了。后面讲解过transition后会结合一些CSS动画来深入挖掘这个属性的用法。

```
transform-origin(X,Y):用来设置元素的运动的基点（参照点）。默认点是元素的中心点。
其中X和Y的值可以是百分值,em,px，其中X也可以是字符参数值left,center,right；Y和X一样除了百分值外还可以设置字符值top,center,bottom，
这个看上去跟background-position设置类似
```
下面我们先用几个实例看一下：  
分别代表transform-origin:(left,top)，transform-origin:right，transform-origin(25%,75%)的效果图。

![left top](/img/origin-x-y.png)
![right](/img/origin-x.png)
![25% 75%](/img/origin-per.png)

```
left,center right是水平方向取值，对应的百分值为left=0%;center=50%;right=100%
而top center bottom是垂直方向的取值，其中top=0%;center=50%;bottom=100%
如果只取一个值，表示垂直方向值不变(前提是该值为百分比形式)
```

#### transition
了解了transform的相关概念，我们知道它只是一个静态属性，并不能呈现动画效果，也就不能说是CSS动画。所以我们接下来将介绍CSS3的另一个属性，它可以实现过渡动画效果，但又不是纯粹的动画，因为这些过渡动画效果的实现需要借助鼠标单击、获得焦点、被点击或者对元素的任何改变来触发。它就是接下来要谈的transition。
```
transition在W3C标准中式这样描述的：“CSS3的transition允许CSS的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值。”
```
我们在页面开发过程中，往往会需要书写大量的特效，来使我们的页面交互更加友好，而一般特效都是用JS来控制的，但对于一些简单的特效，过度的使用JS方法无疑会影响到系统的性能，这是作为一个开发不能接受的，而transition的出现恰恰能够解决这个问题。

这里举个简单例子，我们针对一个元素，希望在鼠标移上去后宽度加宽一倍，一般的实现效果和添加了过渡动画的效果如下：

![过渡动画的区别](/img/transition_1.gif)
主要代码如下：
```
html代码
    <div class="normal box"></div>
    <div class="special box"></div>
css代码
    .box{
            width: 150px;
            height: 100px;
            background-color: #1b6d85;
            margin-bottom: 5px;
    }
    .box:hover{
            width: 300px;
    }
    .special{
            -webkit-transition: width 0.5s;
            transition: width 0.5s;
    }
```
显然，过渡动画的效果要比直接变化更富有灵性，且实现这个效果也仅仅只需要简单的两行css样式，高效且方便。

接下来简要介绍下其用法：

